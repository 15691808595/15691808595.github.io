(window.webpackJsonp=window.webpackJsonp||[]).push([[81],{191:function(t,a,e){t.exports=e.p+"assets/img/16a96f4b64f0ad8a.11407855.gif"},216:function(t,a,e){"use strict";e.r(a);var s=e(0),r=Object(s.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"正则表达式的先行断言和后行断言一共有4种形式："}},[s("a",{staticClass:"header-anchor",attrs:{href:"#正则表达式的先行断言和后行断言一共有4种形式："}},[t._v("#")]),t._v(" 正则表达式的先行断言和后行断言一共有4种形式：")]),t._v(" "),s("ol",[s("li",[s("code",[t._v("(?=pattern)")]),t._v(" 零宽正向先行断言(zero-width positive lookahead assertion)")]),t._v(" "),s("li",[s("code",[t._v("(?!pattern)")]),t._v("零宽负向先行断言(zero-width negative lookahead assertion)")]),t._v(" "),s("li",[s("code",[t._v("(?<=pattern)")]),t._v(" 零宽正向后行断言(zero-width positive lookbehind assertion)")]),t._v(" "),s("li",[s("code",[t._v("(?<!pattern)")]),t._v(" 零宽负向后行断言(zero-width negative lookbehind assertion)")])]),t._v(" "),s("p",[t._v("这里面的"),s("code",[t._v("pattern")]),t._v("是一个正则表达式。")]),t._v(" "),s("p",[t._v("如同"),s("code",[t._v("^")]),t._v("代表开头，"),s("code",[t._v("$")]),t._v("代表结尾，"),s("code",[t._v("\\b")]),t._v("代表单词边界一样，先行断言和后行断言也有类似的作用，它们只匹配某些位置，在匹配过程中，不占用字符，所以被称为“零宽”。所谓位置，是指字符串中(每行)第一个字符的左边、最后一个字符的右边以及相邻字符的中间（假设文字方向是头左尾右）。下面分别举例来说明这4种断言的含义。")]),t._v(" "),s("h3",{attrs:{id:"pattern-正向先行断言"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#pattern-正向先行断言"}},[t._v("#")]),t._v(" "),s("code",[t._v("(?=pattern)")]),t._v(" 正向先行断言")]),t._v(" "),s("p",[t._v("代表字符串中的一个位置，紧接该位置之后的字符序列能够匹配"),s("code",[t._v("pattern")]),t._v("。")]),t._v(" "),s("p",[t._v("例如对"),s("code",[t._v("a regular expression")]),t._v("这个字符串，要想匹配"),s("code",[t._v("regular")]),t._v("中的re，但不能匹配"),s("code",[t._v("expression")]),t._v("中的"),s("code",[t._v("re")]),t._v("，可以用"),s("code",[t._v("re(?=gular)")]),t._v("，该表达式限定了"),s("code",[t._v("re")]),t._v("右边的位置，这个位置之后是"),s("code",[t._v("gular")]),t._v("，但并不消耗"),s("code",[t._v("gular")]),t._v("这些字符，将表达式改为"),s("code",[t._v("re(?=gular).")]),t._v("，将会匹配"),s("code",[t._v("reg")]),t._v("，元字符.匹配了"),s("code",[t._v("g")]),t._v("，括号这一砣匹配了"),s("code",[t._v("e和g")]),t._v("之间的位置。")]),t._v(" "),s("h3",{attrs:{id:"pattern-负向先行断言"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#pattern-负向先行断言"}},[t._v("#")]),t._v(" "),s("code",[t._v("(?!pattern)")]),t._v(" 负向先行断言")]),t._v(" "),s("p",[t._v("代表字符串中的一个位置，紧接该位置之后的字符序列不能匹配"),s("code",[t._v("pattern")]),t._v("。")]),t._v(" "),s("p",[t._v("例如对"),s("code",[t._v("regex represents regular expression")]),t._v("这个字符串，要想匹配除"),s("code",[t._v("regex")]),t._v("和"),s("code",[t._v("regular")]),t._v("之外的re，可以用"),s("code",[t._v("re(?!g)")]),t._v("，该表达式限定了"),s("code",[t._v("re")]),t._v("右边的位置，这个位置后面不是字符"),s("code",[t._v("g")]),t._v("。负向和正向的区别，就在于该位置之后的字符能否匹配括号中的表达式。")]),t._v(" "),s("h3",{attrs:{id:"pattern-正向后行断言"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#pattern-正向后行断言"}},[t._v("#")]),t._v(" "),s("code",[t._v("(?<=pattern)")]),t._v(" 正向后行断言")]),t._v(" "),s("p",[t._v("代表字符串中的一个位置，紧接该位置之前的字符序列能够匹配"),s("code",[t._v("pattern")]),t._v("。")]),t._v(" "),s("p",[t._v("例如对"),s("code",[t._v("regex represents regular expression")]),t._v("这个字符串，有4个单词，要想匹配单词内部的"),s("code",[t._v("re")]),t._v("，但不匹配单词开头的"),s("code",[t._v("re")]),t._v("，可以用"),s("code",[t._v("(?<=\\w)re")]),t._v("，单词内部的"),s("code",[t._v("re")]),t._v("，在"),s("code",[t._v("re")]),t._v("前面应该是一个单词字符。之所以叫后行断言，是因为正则表达式引擎在匹配字符串和表达式时，是从前向后逐个扫描字符串中的字符，并判断是否与表达式符合，当在表达式中遇到该断言时，正则表达式引擎需要往字符串前端检测已扫描过的字符，相对于扫描方向是向后的。")]),t._v(" "),s("h3",{attrs:{id:"pattern-负向后行断言"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#pattern-负向后行断言"}},[t._v("#")]),t._v(" "),s("code",[t._v("(?<!pattern)")]),t._v(" 负向后行断言")]),t._v(" "),s("p",[t._v("代表字符串中的一个位置，紧接该位置之前的字符序列不能匹配"),s("code",[t._v("pattern")]),t._v("。")]),t._v(" "),s("p",[t._v("例如对"),s("code",[t._v("regex represents regular expression")]),t._v("这个字符串，要想匹配单词开头的"),s("code",[t._v("re")]),t._v("，可以用"),s("code",[t._v("(?<!\\w)re")]),t._v("。单词开头的"),s("code",[t._v("re")]),t._v("，在本例中，也就是指不在单词内部的"),s("code",[t._v("re")]),t._v("，即"),s("code",[t._v("re")]),t._v("前面不是单词字符。当然也可以用"),s("code",[t._v("\\bre")]),t._v("来匹配。")]),t._v(" "),s("p",[t._v("对于这4个断言的理解，可以从两个方面入手：")]),t._v(" "),s("ol",[s("li",[t._v("关于先行(lookahead)和后行(lookbehind)：正则表达式引擎在执行字符串和表达式匹配时，会从头到尾（从前到后）连续扫描字符串中的字符，设想有一个扫描指针指向字符边界处并随匹配过程移动。先行断言，是当扫描指针位于某处时，引擎会尝试匹配指针还未扫过的字符，先于指针到达该字符，故称为先行。后行断言，引擎会尝试匹配指针已扫过的字符，后于指针到达该字符，故称为后行。")]),t._v(" "),s("li",[t._v("关于正向(positive)和负向(negative)：正向就表示匹配括号中的表达式，负向表示不匹配。")])]),t._v(" "),s("p",[t._v("对这4个断言形式的记忆：")]),t._v(" "),s("ol",[s("li",[t._v("先行和后行：后行断言"),s("code",[t._v("(?<=pattern)")]),t._v("、"),s("code",[t._v("(?<!pattern)")]),t._v("中，有个小于号，同时也是箭头，对于自左至右的文本方向，这个箭头是指向后的，这也比较符合我们的习惯。把小于号去掉，就是先行断言。")]),t._v(" "),s("li",[t._v("正向和负向：不等于(!=)、逻辑非(!)都是用!号来表示，所以有!号的形式表示不匹配、负向；将!号换成=号，就表示匹配、正向。")])]),t._v(" "),s("p",[t._v("我们经常用正则表达式来检测一个字符串中包含某个子串，要表示一个字符串中不包含某个字符或某些字符也很容易，用[^...]形式就可以了。要表示一个字符串中不包含某个子串（由字符序列构成）呢？用[^...]这种形式就不行了，这时就要用到（负向）先行断言或后行断言、或同时使用。")]),t._v(" "),s("p",[t._v("例如判断一句话中包含"),s("code",[t._v("this")]),t._v("，但不包含"),s("code",[t._v("that")]),t._v("。")]),t._v(" "),s("p",[t._v("包含"),s("code",[t._v("this")]),t._v("比较好办，一句话中不包含"),s("code",[t._v("that")]),t._v("，可以认为这句话中每个字符的前面都不是"),s("code",[t._v("that")]),t._v("或每个字符的后面都不是"),s("code",[t._v("that")]),t._v("。正则表达式如下："),s("code",[t._v("^((?<!that).)*this((?<!that).)*$")]),t._v("或 "),s("code",[t._v("^(.(?!that))*this(.(?!that))*$")])]),t._v(" "),s("p",[t._v("对于"),s("code",[t._v("this is the case")]),t._v("这句话，两个表达式都能够匹配成功，而"),s("code",[t._v("note that this is the case")]),t._v("都匹配失败。")]),t._v(" "),s("p",[t._v("在一般情况下，这两个表达式基本上都能够满足要求了。考虑极端情况，如一句话以"),s("code",[t._v("that")]),t._v("开头、以"),s("code",[t._v("that")]),t._v("结尾、"),s("code",[t._v("that和this")]),t._v("连在一起时，上述表达式就可能不胜任了。")]),t._v(" "),s("p",[t._v("如"),s("code",[t._v("note thatthis is the case")]),t._v("或者"),s("code",[t._v("this is the case, not that")]),t._v("等。只要灵活运用这几个断言，就很容易解决：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("^")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("that"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("that"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("$\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("^")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("that"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("that"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("$\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("^")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("that"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("that"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("$\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("^")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("that"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("that"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("$\n")])])]),s("p",[t._v("这4个正则表达式测试上述的几句话，结果都能够满足要求。")]),t._v(" "),s("p",[t._v("上述4种断言，括号里的"),s("code",[t._v("pattern")]),t._v("本身是一个正则表达式。但对2种后行断言有所限制，在"),s("code",[t._v("Perl和Python")]),t._v("中，这个表达式必须是定长(fixed length)的，即不能使用"),s("code",[t._v("*、+、?")]),t._v("等元字符，如"),s("code",[t._v("(?<=abc)")]),t._v("没有问题，但"),s("code",[t._v("(?<=a*bc)")]),t._v("是不被支持的，特别是当表达式中含有|连接的分支时，各个分支的长度必须相同。之所以不支持变长表达式，是因为当引擎检查后行断言时，无法确定要回溯多少步。Java支持"),s("code",[t._v("?、{m}、{n,m}")]),t._v("等符号，但同样不支持"),s("code",[t._v("*、+")]),t._v("字符。"),s("code",[t._v("Javascript")]),t._v("ES6+支持后行断言，")]),t._v(" "),s("h2",{attrs:{id:"今日图-dns-劫持"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#今日图-dns-劫持"}},[t._v("#")]),t._v(" 今日图 - DNS 劫持")]),t._v(" "),s("p",[s("img",{attrs:{src:e(191),alt:"16a96f4b64f0ad8a.gif"}})])])}),[],!1,null,null,null);a.default=r.exports}}]);