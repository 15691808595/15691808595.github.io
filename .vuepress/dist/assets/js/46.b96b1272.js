(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{142:function(v,_,e){v.exports=e.p+"assets/img/123_20190521095200.daa7dc7a.jpg"},294:function(v,_,e){"use strict";e.r(_);var t=e(0),o=Object(t.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"特点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[v._v("#")]),v._v(" 特点")]),v._v(" "),t("ol",[t("li",[v._v("简单快速 ：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有"),t("code",[v._v("GET")]),v._v("、"),t("code",[v._v("HEAD")]),v._v("、"),t("code",[v._v("POST")]),v._v("。每种方法规定了客户与服务器联系的类型不同。由于"),t("code",[v._v("HTTP")]),v._v("协议简单，使得"),t("code",[v._v("HTTP")]),v._v("服务器的程序规模小，因而通信速度很快。")]),v._v(" "),t("li",[v._v("灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记")]),v._v(" "),t("li",[v._v("连接： 无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。")]),v._v(" "),t("li",[v._v("无状态："),t("code",[v._v("HTTP")]),v._v("协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。")])]),v._v(" "),t("h2",{attrs:{id:"报文"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#报文"}},[v._v("#")]),v._v(" 报文")]),v._v(" "),t("ul",[t("li",[v._v("请求报文：请求行，请求头，空行，请求体")]),v._v(" "),t("li",[v._v("响应报文：状态行，响应头，空行，响应体")])]),v._v(" "),t("h2",{attrs:{id:"请求方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#请求方法"}},[v._v("#")]),v._v(" 请求方法")]),v._v(" "),t("ol",[t("li",[t("code",[v._v("GET")]),v._v("     请求指定的页面信息，并返回实体主体。")]),v._v(" "),t("li",[t("code",[v._v("HEAD")]),v._v("     类似于"),t("code",[v._v("get")]),v._v("请求，只不过返回的响应中没有具体的内容，用于获取报头")]),v._v(" "),t("li",[t("code",[v._v("POST")]),v._v("     向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。"),t("code",[v._v("POST")]),v._v("请求可能会导致新的资源的建立和/或已有资源的修改。")]),v._v(" "),t("li",[t("code",[v._v("PUT")]),v._v("     从客户端向服务器传送的数据取代指定的文档的内容。")]),v._v(" "),t("li",[t("code",[v._v("DELETE")]),v._v("      请求服务器删除指定的页面。")]),v._v(" "),t("li",[t("code",[v._v("CONNECT")]),v._v(" "),t("code",[v._v("HTTP/1.1")]),v._v("协议中预留给能够将连接改为管道方式的代理服务器。")]),v._v(" "),t("li",[t("code",[v._v("OPTIONS")]),v._v("     允许客户端查看服务器的性能。")]),v._v(" "),t("li",[t("code",[v._v("TRACE")]),v._v("     回显服务器收到的请求，主要用于测试或诊断。")])]),v._v(" "),t("h3",{attrs:{id:"get和post的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#get和post的区别"}},[v._v("#")]),v._v(" get和post的区别")]),v._v(" "),t("ol",[t("li",[t("code",[v._v("get")]),v._v("在浏览器回退时是无害的，"),t("code",[v._v("post")]),v._v("会再次提交请求")]),v._v(" "),t("li",[t("code",[v._v("get")]),v._v("的url可以收藏，"),t("code",[v._v("post")]),v._v("不可以")]),v._v(" "),t("li",[t("code",[v._v("get")]),v._v("请求会主动缓存，"),t("code",[v._v("post")]),v._v("不会，除非手动设置")])]),v._v(" "),t("h3",{attrs:{id:"状态码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#状态码"}},[v._v("#")]),v._v(" 状态码")]),v._v(" "),t("ul",[t("li",[v._v("1xx：指示信息--表示请求已接收，继续处理")]),v._v(" "),t("li",[v._v("2xx：成功--表示请求已被成功接收、理解、接受")]),v._v(" "),t("li",[v._v("3xx：重定向--要完成请求必须进行更进一步的操作")]),v._v(" "),t("li",[v._v("4xx：客户端错误--请求有语法错误或请求无法实现")]),v._v(" "),t("li",[v._v("5xx：服务器端错误--服务器未能实现合法的请求")])]),v._v(" "),t("p",[t("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/206",target:"_blank",rel:"noopener noreferrer"}},[v._v("more"),t("OutboundLink")],1)]),v._v(" "),t("h2",{attrs:{id:"持久连接"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#持久连接"}},[v._v("#")]),v._v(" 持久连接")]),v._v(" "),t("p",[v._v("什么是持久连接？对于"),t("code",[v._v("HTTP")]),v._v("协议而言，它是基于请求响应模型，"),t("code",[v._v("Client")]),v._v("向"),t("code",[v._v("Server")]),v._v("发请求时，先建立一条"),t("code",[v._v("HTTP")]),v._v("连接，"),t("code",[v._v("Server")]),v._v("给"),t("code",[v._v("Client")]),v._v("响应数据后，连接关闭。")]),v._v(" "),t("p",[v._v("当"),t("code",[v._v("Client")]),v._v("发送下一个请求时，需要重新再建立"),t("code",[v._v("HTTP")]),v._v("连接，这种方式就是：一个请求响应需要占用一条HTTP连接。而持久连接就是：只需要建立一条连接，然后在这条连接上 传输多个请求和响应。")]),v._v(" "),t("p",[v._v("与持久连接相关的字段\n"),t("code",[v._v("HTTP1.0")]),v._v("中有一个"),t("code",[v._v("Connection")]),v._v("首部字段，它是一个逐跳首部字段。"),t("code",[v._v("Connection:Keep-Alive")]),v._v("，表示希望将此条连接作为持久连接。\n"),t("code",[v._v("HTTP1.1")]),v._v("中，建立的"),t("code",[v._v("HTTP")]),v._v("请求默认是持久连接的。当"),t("code",[v._v("Client")]),v._v("确定不再需要向"),t("code",[v._v("Server")]),v._v("发送数据时，它可以关闭连接，即在发送首部中添加"),t("code",[v._v("Connection:Closed")]),v._v("字段。")]),v._v(" "),t("h2",{attrs:{id:"管线化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#管线化"}},[v._v("#")]),v._v(" 管线化")]),v._v(" "),t("ul",[t("li",[v._v("①管线化机制通过持久连接完成，仅"),t("code",[v._v("HTTP/1.1")]),v._v("支持此技术")]),v._v(" "),t("li",[v._v("②只有"),t("code",[v._v("GET")]),v._v("和"),t("code",[v._v("HEAD")]),v._v("请求可以进行管线化，而"),t("code",[v._v("POST")]),v._v("会有所限制")]),v._v(" "),t("li",[v._v("③初次创建连接时不应启动管线机制，因为对方服务器不一定支持"),t("code",[v._v("HTTP/1.1")]),v._v("版本的协议")])]),v._v(" "),t("p",[v._v("持久连接的时候，某个连接消息传递类似于\n持久连接的一个最大的好处是：大大减少了连接的建立以及关闭时延。\n“缺点”，请求响应是顺序执行的。只有在请求1的响应收到之后，才会发送请求2，这就是持久连接与管道化连接不同的地方。\n"),t("code",[v._v("请求1=>响应1=>请求2=>响应2")])]),v._v(" "),t("p",[v._v("管线化后\n"),t("code",[v._v("请求1=>请求2=>响应1=>响应2")])]),v._v(" "),t("p",[v._v("管道化连接是需要持久连接支持的。管道化连接是在持久连接的基础上，以“流水线”的方式发送请求：不需要等到请求1的响应到达"),t("code",[v._v("Client")]),v._v("，就可以发送请求2....")]),v._v(" "),t("h2",{attrs:{id:"今日图-520扎心了"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#今日图-520扎心了"}},[v._v("#")]),v._v(" 今日图 520扎心了")]),v._v(" "),t("p",[t("img",{attrs:{src:e(142),alt:"123_20190521095200.jpg"}})])])}),[],!1,null,null,null);_.default=o.exports}}]);